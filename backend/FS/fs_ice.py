# **********************************************************************
#
# Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.4.2
#
# <auto-generated>
#
# Generated from file `fs.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy, __builtin__

# Start of module FS
_M_FS = Ice.openModule('FS')
__name__ = 'FS'

if not _M_FS.__dict__.has_key('Example'):
    _M_FS.Example = Ice.createTempClass()
    class Example(Ice.Object):
        def __init__(self, apilevel=0):
            self.apilevel = apilevel

        def ice_ids(self, current=None):
            return ('::FS::Example', '::Ice::Object')

        def ice_id(self, current=None):
            return '::FS::Example'

        def ice_staticId():
            return '::FS::Example'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_FS._t_Example)

        __repr__ = __str__

    _M_FS.ExamplePrx = Ice.createTempClass()
    class ExamplePrx(Ice.ObjectPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_FS.ExamplePrx.ice_checkedCast(proxy, '::FS::Example', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_FS.ExamplePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_FS._t_ExamplePrx = IcePy.defineProxy('::FS::Example', ExamplePrx)

    _M_FS._t_Example = IcePy.defineClass('::FS::Example', Example, (), False, None, (), (('apilevel', (), IcePy._t_short),))
    Example._ice_type = _M_FS._t_Example

    _M_FS.Example = Example
    del Example

    _M_FS.ExamplePrx = ExamplePrx
    del ExamplePrx

_M_FS._lambda = 0

if not _M_FS.__dict__.has_key('_t_StringSeq'):
    _M_FS._t_StringSeq = IcePy.defineSequence('::FS::StringSeq', (), IcePy._t_string)

if not _M_FS.__dict__.has_key('_t_StringDict'):
    _M_FS._t_StringDict = IcePy.defineDictionary('::FS::StringDict', (), IcePy._t_string, IcePy._t_string)

if not _M_FS.__dict__.has_key('mystruct'):
    _M_FS.mystruct = Ice.createTempClass()
    class mystruct(object):
        def __init__(self, mytype=0, bo=False, by=0, sh=0, i=0, l=0, f=0.0, d=0.0, str='', ss=None, sd=None, s=None, prx=None):
            self.mytype = mytype
            self.bo = bo
            self.by = by
            self.sh = sh
            self.i = i
            self.l = l
            self.f = f
            self.d = d
            self.str = str
            self.ss = ss
            self.sd = sd
            self.s = s
            self.prx = prx

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.mytype)
            _h = 5 * _h + __builtin__.hash(self.bo)
            _h = 5 * _h + __builtin__.hash(self.by)
            _h = 5 * _h + __builtin__.hash(self.sh)
            _h = 5 * _h + __builtin__.hash(self.i)
            _h = 5 * _h + __builtin__.hash(self.l)
            _h = 5 * _h + __builtin__.hash(self.f)
            _h = 5 * _h + __builtin__.hash(self.d)
            _h = 5 * _h + __builtin__.hash(self.str)
            if self.ss:
                for _i0 in self.ss:
                    _h = 5 * _h + __builtin__.hash(_i0)
            if self.sd:
                for _i1 in self.sd:
                    _h = 5 * _h + __builtin__.hash(_i1)
                    _h = 5 * _h + __builtin__.hash(self.sd[_i1])
            _h = 5 * _h + __builtin__.hash(self.s)
            _h = 5 * _h + __builtin__.hash(self.prx)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_FS.mystruct):
                return self.mytype < other.mytype or self.bo < other.bo or self.by < other.by or self.sh < other.sh or self.i < other.i or self.l < other.l or self.f < other.f or self.d < other.d or self.str < other.str or self.ss < other.ss or self.sd < other.sd or self.s < other.s or self.prx < other.prx
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_FS.mystruct):
                return self.mytype <= other.mytype or self.bo <= other.bo or self.by <= other.by or self.sh <= other.sh or self.i <= other.i or self.l <= other.l or self.f <= other.f or self.d <= other.d or self.str <= other.str or self.ss <= other.ss or self.sd <= other.sd or self.s <= other.s or self.prx <= other.prx
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_FS.mystruct):
                return self.mytype == other.mytype and self.bo == other.bo and self.by == other.by and self.sh == other.sh and self.i == other.i and self.l == other.l and self.f == other.f and self.d == other.d and self.str == other.str and self.ss == other.ss and self.sd == other.sd and self.s == other.s and self.prx == other.prx
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_FS.mystruct):
                return self.mytype != other.mytype or self.bo != other.bo or self.by != other.by or self.sh != other.sh or self.i != other.i or self.l != other.l or self.f != other.f or self.d != other.d or self.str != other.str or self.ss != other.ss or self.sd != other.sd or self.s != other.s or self.prx != other.prx
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_FS.mystruct):
                return self.mytype > other.mytype or self.bo > other.bo or self.by > other.by or self.sh > other.sh or self.i > other.i or self.l > other.l or self.f > other.f or self.d > other.d or self.str > other.str or self.ss > other.ss or self.sd > other.sd or self.s > other.s or self.prx > other.prx
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_FS.mystruct):
                return self.mytype >= other.mytype or self.bo >= other.bo or self.by >= other.by or self.sh >= other.sh or self.i >= other.i or self.l >= other.l or self.f >= other.f or self.d >= other.d or self.str >= other.str or self.ss >= other.ss or self.sd >= other.sd or self.s >= other.s or self.prx >= other.prx
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_FS._t_mystruct)

        __repr__ = __str__

    _M_FS._t_mystruct = IcePy.defineStruct('::FS::mystruct', mystruct, (), (
        ('mytype', (), IcePy._t_int),
        ('bo', (), IcePy._t_bool),
        ('by', (), IcePy._t_byte),
        ('sh', (), IcePy._t_short),
        ('i', (), IcePy._t_int),
        ('l', (), IcePy._t_long),
        ('f', (), IcePy._t_float),
        ('d', (), IcePy._t_double),
        ('str', (), IcePy._t_string),
        ('ss', (), _M_FS._t_StringSeq),
        ('sd', (), _M_FS._t_StringDict),
        ('s', (), _M_FS._t_Example),
        ('prx', (), IcePy._t_ObjectPrx)
    ))

    _M_FS.mystruct = mystruct
    del mystruct

if not _M_FS.__dict__.has_key('EnumNone'):
    _M_FS.EnumNone = Ice.createTempClass()
    class EnumNone(object):

        def __init__(self, val):
            assert(val >= 0 and val < 1)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_FS.EnumNone):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_FS.EnumNone):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_FS.EnumNone):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_FS.EnumNone):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_FS.EnumNone):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_FS.EnumNone):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('None',)

    EnumNone._None = EnumNone(0)

    _M_FS._t_EnumNone = IcePy.defineEnum('::FS::EnumNone', EnumNone, (), (EnumNone._None,))

    _M_FS.EnumNone = EnumNone
    del EnumNone

if not _M_FS.__dict__.has_key('myexcep'):
    _M_FS.myexcep = Ice.createTempClass()
    class myexcep(Ice.UserException):
        def __init__(self, _lambda=0):
            self._lambda = _lambda

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'FS::myexcep'

    _M_FS._t_myexcep = IcePy.defineException('::FS::myexcep', myexcep, (), None, (('_lambda', (), IcePy._t_int),))
    myexcep._ice_type = _M_FS._t_myexcep

    _M_FS.myexcep = myexcep
    del myexcep

if not _M_FS.__dict__.has_key('_t_File'):
    _M_FS._t_File = IcePy.defineSequence('::FS::File', (), IcePy._t_byte)

if not _M_FS.__dict__.has_key('Api'):
    _M_FS.Api = Ice.createTempClass()
    class Api(Ice.Object):
        def __init__(self):
            if __builtin__.type(self) == _M_FS.Api:
                raise RuntimeError('FS.Api is an abstract class')

        def ice_ids(self, current=None):
            return ('::FS::Api', '::Ice::Object')

        def ice_id(self, current=None):
            return '::FS::Api'

        def ice_staticId():
            return '::FS::Api'
        ice_staticId = staticmethod(ice_staticId)

        def getWidgets(self, current=None):
            pass

        def version(self, current=None):
            pass

        def getFile(self, path, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_FS._t_Api)

        __repr__ = __str__

    _M_FS.ApiPrx = Ice.createTempClass()
    class ApiPrx(Ice.ObjectPrx):

        def getWidgets(self, _ctx=None):
            return _M_FS.Api._op_getWidgets.invoke(self, ((), _ctx))

        def begin_getWidgets(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_FS.Api._op_getWidgets.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_getWidgets(self, _r):
            return _M_FS.Api._op_getWidgets.end(self, _r)

        def version(self, _ctx=None):
            return _M_FS.Api._op_version.invoke(self, ((), _ctx))

        def begin_version(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_FS.Api._op_version.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_version(self, _r):
            return _M_FS.Api._op_version.end(self, _r)

        def getFile(self, path, _ctx=None):
            return _M_FS.Api._op_getFile.invoke(self, ((path, ), _ctx))

        def begin_getFile(self, path, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_FS.Api._op_getFile.begin(self, ((path, ), _response, _ex, _sent, _ctx))

        def end_getFile(self, _r):
            return _M_FS.Api._op_getFile.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_FS.ApiPrx.ice_checkedCast(proxy, '::FS::Api', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_FS.ApiPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_FS._t_ApiPrx = IcePy.defineProxy('::FS::Api', ApiPrx)

    _M_FS._t_Api = IcePy.defineClass('::FS::Api', Api, (), True, None, (), ())
    Api._ice_type = _M_FS._t_Api

    Api._op_getWidgets = IcePy.Operation('getWidgets', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (), (), None, ())
    Api._op_version = IcePy.Operation('version', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (), (((), IcePy._t_string),), None, ())
    Api._op_getFile = IcePy.Operation('getFile', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), _M_FS._t_File, ())

    _M_FS.Api = Api
    del Api

    _M_FS.ApiPrx = ApiPrx
    del ApiPrx

if not _M_FS.__dict__.has_key('Widget'):
    _M_FS.Widget = Ice.createTempClass()
    class Widget(Ice.Object):
        def __init__(self):
            if __builtin__.type(self) == _M_FS.Widget:
                raise RuntimeError('FS.Widget is an abstract class')

        def ice_ids(self, current=None):
            return ('::FS::Widget', '::Ice::Object')

        def ice_id(self, current=None):
            return '::FS::Widget'

        def ice_staticId():
            return '::FS::Widget'
        ice_staticId = staticmethod(ice_staticId)

        def getName(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_FS._t_Widget)

        __repr__ = __str__

    _M_FS.WidgetPrx = Ice.createTempClass()
    class WidgetPrx(Ice.ObjectPrx):

        def getName(self, _ctx=None):
            return _M_FS.Widget._op_getName.invoke(self, ((), _ctx))

        def begin_getName(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_FS.Widget._op_getName.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_getName(self, _r):
            return _M_FS.Widget._op_getName.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_FS.WidgetPrx.ice_checkedCast(proxy, '::FS::Widget', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_FS.WidgetPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_FS._t_WidgetPrx = IcePy.defineProxy('::FS::Widget', WidgetPrx)

    _M_FS._t_Widget = IcePy.defineClass('::FS::Widget', Widget, (), True, None, (), ())
    Widget._ice_type = _M_FS._t_Widget

    Widget._op_getName = IcePy.Operation('getName', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (), (), None, ())

    _M_FS.Widget = Widget
    del Widget

    _M_FS.WidgetPrx = WidgetPrx
    del WidgetPrx

if not _M_FS.__dict__.has_key('GenericError'):
    _M_FS.GenericError = Ice.createTempClass()
    class GenericError(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'FS::GenericError'

    _M_FS._t_GenericError = IcePy.defineException('::FS::GenericError', GenericError, (), None, (('reason', (), IcePy._t_string),))
    GenericError._ice_type = _M_FS._t_GenericError

    _M_FS.GenericError = GenericError
    del GenericError

if not _M_FS.__dict__.has_key('NoAuthorized'):
    _M_FS.NoAuthorized = Ice.createTempClass()
    class NoAuthorized(_M_FS.GenericError):
        def __init__(self, reason=''):
            _M_FS.GenericError.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'FS::NoAuthorized'

    _M_FS._t_NoAuthorized = IcePy.defineException('::FS::NoAuthorized', NoAuthorized, (), _M_FS._t_GenericError, ())
    NoAuthorized._ice_type = _M_FS._t_NoAuthorized

    _M_FS.NoAuthorized = NoAuthorized
    del NoAuthorized

# End of module FS
